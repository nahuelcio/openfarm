// @ts-expect-error - TODO: Move orchestration to a shared package or fix imports
import type { PodProvisionConfig } from "@openfarm/agent-runner/orchestration";
import { StepAction } from "@openfarm/core/constants/actions";
import { err, ok, type Result } from "@openfarm/result";
import type { StepExecutionRequest } from "../types";
import {
  type PlatformCreatePrConfig,
  type PlatformPostCommentConfig,
  type PlatformProvisionPodConfig,
  validateConfig,
} from "./validation";

/**
 * Cleans up text by removing unresolved expressions and fixing formatting.
 */
function cleanupText(text: string): string {
  let result = text;

  // Remove any remaining ${...} expressions
  result = result.replace(/\$\{[^}]+\}/g, "");

  // Remove literal "undefined" and "null" strings
  result = result.replace(/\bundefined\b/g, "");
  result = result.replace(/\bnull\b/g, "");

  // Fix multiple consecutive newlines
  result = result.replace(/\n{3,}/g, "\n\n");

  return result.trim();
}

/**
 * Executes platform.create_pr action.
 * This function performs I/O operations (API calls to create pull requests) but receives all dependencies explicitly,
 * making it testable through dependency injection. The function is deterministic given the same inputs.
 *
 * @param request - Step execution request containing step, context, logger, flags, and services
 * @returns Result with PR URL
 *
 * @example
 * ```typescript
 * const request: StepExecutionRequest = {
 *   step,
 *   context,
 *   logger: log,
 *   flags: { previewMode: false },
 *   services: { platformAdapter }
 * };
 * const result = await executePlatformCreatePr(request);
 * ```
 */
export async function executePlatformCreatePr(
  request: StepExecutionRequest
): Promise<Result<string>> {
  const { step, context, logger, flags, services } = request;
  const { config } = step;

  if (!services.platformAdapter) {
    return err(
      new Error(
        "platformAdapter service is required for platform.create_pr action"
      )
    );
  }

  const validation = validateConfig<PlatformCreatePrConfig>(
    StepAction.PLATFORM_CREATE_PR,
    config
  );
  if (!validation.ok) {
    return validation;
  }
  const validatedConfig = validation.value;

  const { workItem, branchName } = context;

  // Build title - use config value or fallback to workItem title
  let title = validatedConfig.title || `fix: ${workItem.title}`;

  // If title contains unresolved expressions, use simple fallback
  if (title.includes("${")) {
    title = `fix: ${workItem.title}`;
  }
  title = cleanupText(title) || `fix: ${workItem.title}`;

  // Build description - use config value or fallback to workItem description
  let description = validatedConfig.description || "";

  // If description contains unresolved expressions, build it directly from workItem
  if (description.includes("${") || !description) {
    // Build a clean description directly from workItem fields
    const parts: string[] = [];

    if (workItem.description) {
      parts.push("## Description");
      parts.push("");
      parts.push(workItem.description);
      parts.push("");
    }

    if (workItem.acceptanceCriteria) {
      parts.push("## Acceptance Criteria");
      parts.push("");
      parts.push(workItem.acceptanceCriteria);
      parts.push("");
    }

    parts.push("---");
    parts.push("");
    parts.push("*Automatically generated by Minions Farm*");

    description = parts.join("\n");
  }

  description =
    cleanupText(description) ||
    workItem.description ||
    `Work item: ${workItem.id}`;

  // Use config.target if provided and valid (not an unresolved expression), otherwise fall back to "main"
  // Check if target is a valid branch name (not containing ${...})
  let targetBranch = validatedConfig.target;
  await logger(
    `PR target branch from config: "${targetBranch || "(not set)"}" (step.config.target = ${JSON.stringify(step.config?.target)})`
  );

  if (!targetBranch || targetBranch.includes("${")) {
    // If target is undefined or contains unresolved expression, always use "main" as safe default
    // This can happen if variable resolution failed in the subworkflow
    targetBranch = "main";
    await logger(
      "Target branch not specified or contains unresolved expression, using default: main"
    );
  }

  // Use config.source if provided and valid (not an unresolved expression), otherwise fall back to branchName
  let sourceBranch = validatedConfig.source;
  if (!sourceBranch || sourceBranch.includes("${")) {
    // If source is undefined or contains unresolved expression, use context branchName
    sourceBranch = branchName;
    if (validatedConfig.source) {
      await logger(
        `Source branch contains unresolved expression "${validatedConfig.source}", using context branch: ${branchName}`
      );
    }
  }

  // Ensure we don't create a PR from a branch to itself
  if (sourceBranch === targetBranch) {
    await logger(
      `Warning: Source and target branches are the same (${sourceBranch}). Using "main" as target.`
    );
    targetBranch = "main";
  }

  if (flags.previewMode) {
    await logger(
      `[Dry Run] Would execute: platform.create_pr with title "${title}" from "${sourceBranch}" to "${targetBranch}"`
    );
    return ok("https://dry-run.local/pr/123");
  }

  // Validate title and description before creating PR
  if (!title || title.trim().length === 0) {
    await logger(
      `Error: PR title is empty. Using fallback: "fix: ${workItem.title}"`
    );
    title = `fix: ${workItem.title}`;
  }

  if (!description || description.trim().length === 0) {
    await logger(
      "Warning: PR description is empty. Using fallback description."
    );
    description = workItem.description || `Work item: ${workItem.id}`;
  }

  await logger(
    `Creating pull request: ${title} (${sourceBranch} -> ${targetBranch})`
  );
  await logger(
    `PR details - Title length: ${title.length}, Description length: ${description.length}`
  );

  const result = await services.platformAdapter.createPullRequest({
    source: sourceBranch,
    target: targetBranch,
    title,
    description,
  });

  if (!result.ok) {
    const error = result as { ok: false; error: Error };
    await logger(
      `Failed to create PR. Title: "${title}", Description preview: "${description.substring(0, 100)}...", Error: ${error.error.message}`
    );
    return err(error.error);
  }

  await logger(`Pull request created: ${result.value}`);
  return ok(result.value); // Return PR URL
}

/**
 * Executes platform.post_comment action.
 * This function performs I/O operations (API calls to post comments) but receives all dependencies explicitly,
 * making it testable through dependency injection. The function is deterministic given the same inputs.
 *
 * @param request - Step execution request containing step, context, logger, flags, and services
 * @returns Result with success message
 *
 * @example
 * ```typescript
 * const request: StepExecutionRequest = {
 *   step,
 *   context,
 *   logger: log,
 *   flags: { previewMode: false },
 *   services: { platformAdapter }
 * };
 * const result = await executePlatformPostComment(request);
 * ```
 */
export async function executePlatformPostComment(
  request: StepExecutionRequest
): Promise<Result<string>> {
  const { step, context, logger, flags, services } = request;
  const { config } = step;

  if (!services.platformAdapter) {
    return err(
      new Error(
        "platformAdapter service is required for platform.post_comment action"
      )
    );
  }

  const validation = validateConfig<PlatformPostCommentConfig>(
    StepAction.PLATFORM_POST_COMMENT,
    config
  );
  if (!validation.ok) {
    return validation;
  }
  const validatedConfig = validation.value;

  const { workItem } = context;

  // Build comment (immutable)
  const comment = validatedConfig.comment
    ? validatedConfig.comment
        .replace("{title}", workItem.title)
        .replace("{id}", workItem.id)
    : `Work item ${workItem.id} has been processed.`;

  if (flags.previewMode) {
    await logger(
      `[Dry Run] Would execute: platform.post_comment on work item ${workItem.id}`
    );
    return ok("Dry run: Comment skipped");
  }

  await logger(`Posting comment to work item ${workItem.id}`);
  const result = await services.platformAdapter.postComment(
    workItem.id,
    comment
  );

  if (!result.ok) {
    const error = result as { ok: false; error: Error };
    return err(error.error);
  }

  return ok("Comment posted successfully");
}

/**
 * Executes platform.provision_pod action.
 * This function provisions an ephemeral Kubernetes Pod for isolated task execution.
 *
 * @param request - Step execution request containing step, context, logger, flags, and services
 * @returns Result with pod name
 */
export async function executePlatformProvisionPod(
  request: StepExecutionRequest
): Promise<Result<string>> {
  const { step, context, logger, flags, services } = request;
  const { config } = step;

  if (!services.kubernetesOrchestrator) {
    return err(
      new Error(
        "kubernetesOrchestrator service is required for platform.provision_pod action"
      )
    );
  }

  const validation = validateConfig<PlatformProvisionPodConfig>(
    StepAction.PLATFORM_PROVISION_POD,
    config
  );
  if (!validation.ok) {
    return validation;
  }
  const validatedConfig = validation.value;

  if (flags.previewMode) {
    await logger(
      `[Dry Run] Would provision ephemeral Pod for job ${context.jobId}`
    );
    return ok(`minion-${context.jobId}`);
  }

  await logger(`Provisioning ephemeral Pod for job ${context.jobId}`);

  const provisionConfig: PodProvisionConfig = {
    jobId: context.jobId,
    workItemId: context.workItem.id,
    repositoryUrl: context.repoUrl || context.workItem.repositoryUrl || "",
    authenticatedRepoUrl:
      context.repoUrl || context.workItem.repositoryUrl || "", // Could be enhanced to pass authenticated URL
    image: validatedConfig.image,
    cloneDepth: validatedConfig.cloneDepth,
    npmCache: validatedConfig.npmCache,
    namespace: validatedConfig.namespace || "minions-farm",
    resources: validatedConfig.resources,
    copilotApiUrl:
      context.agentConfig?.copilotApiBase || process.env.COPILOT_API_URL,
  };

  const result =
    await services.kubernetesOrchestrator.provisionPod(provisionConfig);

  if (!result.ok) {
    const error = result as { ok: false; error: Error };
    return err(error.error);
  }

  await logger(`Pod provisioned successfully: ${result.value}`);
  return ok(result.value); // Return pod name
}

/**
 * Executes platform.destroy_pod action.
 * This function destroys the ephemeral Kubernetes Pod and cleans up resources.
 *
 * @param request - Step execution request containing step, context, logger, flags, and services
 * @returns Result with success message
 */
export async function executePlatformDestroyPod(
  request: StepExecutionRequest
): Promise<Result<string>> {
  const { context, logger, flags, services } = request;

  if (!services.kubernetesOrchestrator) {
    return err(
      new Error(
        "kubernetesOrchestrator service is required for platform.destroy_pod action"
      )
    );
  }

  const podName = context.podName;
  if (!podName) {
    await logger(
      "Warning: No podName in context, skipping pod destruction (may already be destroyed)"
    );
    return ok("No pod to destroy");
  }

  if (flags.previewMode) {
    await logger(`[Dry Run] Would destroy Pod: ${podName}`);
    return ok("Dry run: Pod destruction skipped");
  }

  await logger(`Destroying Pod: ${podName}`);
  const result = await services.kubernetesOrchestrator.destroyPod(podName);

  if (!result.ok) {
    const error = result as { ok: false; error: Error };
    return err(error.error);
  }

  await logger(`Pod destroyed successfully: ${podName}`);
  return ok(`Pod ${podName} destroyed successfully`);
}

/**
 * Routes platform actions to the appropriate executor.
 * This function delegates to executors that perform I/O operations, but receives all dependencies explicitly,
 * making it testable through dependency injection.
 *
 * @param request - Step execution request containing step, context, logger, flags, and services
 * @returns Result with execution result
 */
export async function executePlatformAction(
  request: StepExecutionRequest
): Promise<Result<string>> {
  const { step } = request;
  const action = step.action;

  if (action === StepAction.PLATFORM_CREATE_PR) {
    return executePlatformCreatePr(request);
  }

  if (action === StepAction.PLATFORM_POST_COMMENT) {
    return executePlatformPostComment(request);
  }

  if (action === StepAction.PLATFORM_PROVISION_POD) {
    return executePlatformProvisionPod(request);
  }

  if (action === StepAction.PLATFORM_DESTROY_POD) {
    return executePlatformDestroyPod(request);
  }

  return err(new Error(`Unknown platform action: ${action}`));
}
