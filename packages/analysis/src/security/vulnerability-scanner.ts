import * as ts from "typescript";
import type {
  SecurityAnalysis,
  SecurityHotspot,
  Vulnerability,
} from "../types";
import { generateId, getCodeSnippet, getFiles, readFile } from "../utils";
import { SecretDetector } from "./secret-detector";

export class SecurityAnalyzer {
  private readonly secretDetector: SecretDetector;

  constructor() {
    this.secretDetector = new SecretDetector();
  }

  async analyze(projectPath: string): Promise<SecurityAnalysis> {
    const results: SecurityAnalysis = {
      overallScore: 0,
      vulnerabilities: [],
      secrets: [],
      securityHotspots: [],
      dependencies: [],
    };

    try {
      // 1. Security hotspots (SAST)
      const hotspots = await this.detectSecurityHotspots(projectPath);
      results.securityHotspots.push(...hotspots);

      // 2. Secret detection
      const secrets = await this.secretDetector.detectSecrets(projectPath);
      results.secrets.push(...secrets);

      // 3. Vulnerability detection (basic patterns)
      const vulnerabilities = await this.detectVulnerabilities(projectPath);
      results.vulnerabilities.push(...vulnerabilities);

      // 4. Calculate overall score
      results.overallScore = this.calculateSecurityScore(results);
    } catch (error) {
      console.error("Error in security analysis:", error);
      throw error;
    }

    return results;
  }

  private async detectSecurityHotspots(
    projectPath: string
  ): Promise<SecurityHotspot[]> {
    const hotspots: SecurityHotspot[] = [];
    const files = await getFiles(projectPath, [".ts", ".tsx", ".js", ".jsx"]);

    for (const file of files) {
      try {
        const content = await readFile(file);
        const ast = ts.createSourceFile(
          file,
          content,
          ts.ScriptTarget.Latest,
          true
        );

        // 1. SQL injection vulnerabilities
        const sqlInjections = this.detectSQLInjection(ast, file, content);
        hotspots.push(...sqlInjections);

        // 2. XSS vulnerabilities
        const xssVulnerabilities = this.detectXSS(ast, file, content);
        hotspots.push(...xssVulnerabilities);

        // 3. Path traversal
        const pathTraversals = this.detectPathTraversal(ast, file, content);
        hotspots.push(...pathTraversals);

        // 4. Hardcoded credentials
        const hardcodedCredentials = this.detectHardcodedCredentials(
          ast,
          file,
          content
        );
        hotspots.push(...hardcodedCredentials);
      } catch (error) {
        console.error(
          `[SecurityAnalyzer] Error analyzing file ${file}:`,
          error instanceof Error ? error.message : String(error)
        );
        // Continue processing other files
      }
    }

    return hotspots;
  }

  private detectSQLInjection(
    ast: ts.SourceFile,
    file: string,
    content: string
  ): SecurityHotspot[] {
    const hotspots: SecurityHotspot[] = [];

    // Look for string concatenation in SQL queries
    ast.forEachChild((node) => {
      if (ts.isCallExpression(node)) {
        const callee = node.expression;

        // Check if it's a database query function
        let methodName = "";
        if (ts.isPropertyAccessExpression(callee)) {
          methodName = callee.name.text;
        } else if (ts.isIdentifier(callee)) {
          methodName = callee.text;
        }

        const queryMethods = ["query", "execute", "raw", "run", "all"];
        if (queryMethods.includes(methodName.toLowerCase())) {
          // Check if arguments contain string concatenation
          for (const arg of node.arguments) {
            if (
              ts.isBinaryExpression(arg) &&
              arg.operatorToken.kind === ts.SyntaxKind.PlusToken
            ) {
              const lineNumber =
                ts.getLineAndCharacterOfPosition(ast, arg.getStart()).line + 1;
              const codeSnippet = getCodeSnippet(content, lineNumber, 5);
              hotspots.push({
                id: generateId(),
                type: "sql_injection",
                severity: "high",
                title: "Potential SQL Injection",
                description:
                  "String concatenation in SQL query can lead to SQL injection. Use parameterized queries.",
                affectedFiles: [
                  {
                    path: file,
                    line: lineNumber,
                    codeSnippet: codeSnippet || undefined,
                  },
                ],
                suggestedFix: "Use parameterized queries or query builders",
                codeExample: `
// BAD
db.query('SELECT * FROM users WHERE id = ' + userId);

// GOOD
db.query('SELECT * FROM users WHERE id = ?', [userId]);
                `,
              });
            }
          }
        }
      }
    });

    return hotspots;
  }

  private detectXSS(
    ast: ts.SourceFile,
    file: string,
    content: string
  ): SecurityHotspot[] {
    const hotspots: SecurityHotspot[] = [];

    // Look for dangerous innerHTML assignments
    ast.forEachChild((node) => {
      if (
        ts.isBinaryExpression(node) &&
        node.operatorToken.kind === ts.SyntaxKind.EqualsToken
      ) {
        const left = node.left;

        // Check if it's assigning to innerHTML or dangerouslySetInnerHTML
        if (ts.isPropertyAccessExpression(left)) {
          const propName = left.name.text;
          if (
            propName === "innerHTML" ||
            propName === "dangerouslySetInnerHTML"
          ) {
            // Check if the right side is a variable or expression (not a hardcoded string)
            const right = node.right;
            if (!ts.isStringLiteral(right)) {
              const lineNumber =
                ts.getLineAndCharacterOfPosition(ast, node.getStart()).line + 1;
              const codeSnippet = getCodeSnippet(content, lineNumber, 5);
              hotspots.push({
                id: generateId(),
                type: "xss",
                severity: "high",
                title: "Potential XSS Vulnerability",
                description:
                  "Dynamically setting innerHTML can lead to XSS attacks. Use safe alternatives.",
                affectedFiles: [
                  {
                    path: file,
                    line: lineNumber,
                    codeSnippet: codeSnippet || undefined,
                  },
                ],
                suggestedFix:
                  "Use DOM methods like textContent or sanitization libraries",
                codeExample: `
// BAD
element.innerHTML = userInput;

// GOOD
element.textContent = userInput;
// or use a sanitization library like DOMPurify
element.innerHTML = DOMPurify.sanitize(userInput);
                `,
              });
            }
          }
        }
      }
    });

    return hotspots;
  }

  private detectPathTraversal(
    ast: ts.SourceFile,
    file: string,
    content: string
  ): SecurityHotspot[] {
    const hotspots: SecurityHotspot[] = [];

    // Look for dangerous file operations with user input
    ast.forEachChild((node) => {
      if (ts.isCallExpression(node)) {
        const callee = node.expression;
        let methodName = "";

        if (ts.isPropertyAccessExpression(callee)) {
          methodName = callee.name.text;
        } else if (ts.isIdentifier(callee)) {
          methodName = callee.text;
        }

        const dangerousMethods = [
          "readFile",
          "writeFile",
          "unlink",
          "readdir",
          "stat",
        ];
        if (dangerousMethods.includes(methodName)) {
          // Check if first argument is a variable or expression
          const firstArg = node.arguments[0];
          if (firstArg && !ts.isStringLiteral(firstArg)) {
            const lineNumber =
              ts.getLineAndCharacterOfPosition(ast, node.getStart()).line + 1;
            const codeSnippet = getCodeSnippet(content, lineNumber, 5);
            hotspots.push({
              id: generateId(),
              type: "path_traversal",
              severity: "high",
              title: "Potential Path Traversal",
              description:
                "File operation with user-provided path can lead to path traversal attacks.",
              affectedFiles: [
                {
                  path: file,
                  line: lineNumber,
                  codeSnippet: codeSnippet || undefined,
                },
              ],
              suggestedFix:
                "Validate and sanitize file paths, use path.join, and restrict to allowed directories",
            });
          }
        }
      }
    });

    return hotspots;
  }

  private detectHardcodedCredentials(
    ast: ts.SourceFile,
    file: string,
    content: string
  ): SecurityHotspot[] {
    const hotspots: SecurityHotspot[] = [];

    // Look for property assignments with suspicious names
    ast.forEachChild((node) => {
      if (ts.isPropertyAssignment(node)) {
        const propName = node.name.getText();
        const propValue = node.initializer;

        // Check for credential-related properties
        const credentialProps = [
          "password",
          "apiKey",
          "secret",
          "token",
          "privateKey",
          "accessToken",
        ];
        if (credentialProps.some((p) => propName.toLowerCase().includes(p))) {
          // Check if value is a hardcoded string
          if (ts.isStringLiteral(propValue) && propValue.text.length > 10) {
            const lineNumber =
              ts.getLineAndCharacterOfPosition(ast, node.getStart()).line + 1;
            const codeSnippet = getCodeSnippet(content, lineNumber, 5);
            hotspots.push({
              id: generateId(),
              type: "hardcoded_credentials",
              severity: "critical",
              title: "Hardcoded Credentials",
              description: `Hardcoded credential detected: ${propName}. Use environment variables or secret management.`,
              affectedFiles: [
                {
                  path: file,
                  line: lineNumber,
                  codeSnippet: codeSnippet || undefined,
                },
              ],
              suggestedFix:
                "Remove hardcoded credentials and use environment variables or a secret manager",
            });
          }
        }
      }
    });

    return hotspots;
  }

  private async detectVulnerabilities(
    projectPath: string
  ): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    const files = await getFiles(projectPath, [".ts", ".tsx", ".js", ".jsx"]);

    for (const file of files) {
      try {
        const content = await readFile(file);
        const ast = ts.createSourceFile(
          file,
          content,
          ts.ScriptTarget.Latest,
          true
        );

        // Detect use of eval()
        ast.forEachChild((node) => {
          if (
            ts.isCallExpression(node) &&
            ts.isIdentifier(node.expression) &&
            node.expression.text === "eval"
          ) {
            const lineNumber =
              ts.getLineAndCharacterOfPosition(ast, node.getStart()).line + 1;
            const codeSnippet = getCodeSnippet(content, lineNumber, 5);
            vulnerabilities.push({
              id: generateId(),
              type: "code_injection",
              severity: "high",
              category: "Security",
              title: "Use of eval() detected",
              description:
                "eval() can execute arbitrary code and is a security risk.",
              affectedFiles: [
                {
                  path: file,
                  line: lineNumber,
                  codeSnippet: codeSnippet || undefined,
                },
              ],
              cweId: "CWE-94",
              references: ["https://cwe.mitre.org/data/definitions/94.html"],
              suggestedFix:
                "Avoid eval(). Use alternative approaches like JSON.parse() for parsing JSON.",
            });
          }
        });

        // Detect use of Function constructor
        ast.forEachChild((node) => {
          if (
            ts.isNewExpression(node) &&
            ts.isIdentifier(node.expression) &&
            node.expression.text === "Function"
          ) {
            const lineNumber =
              ts.getLineAndCharacterOfPosition(ast, node.getStart()).line + 1;
            const codeSnippet = getCodeSnippet(content, lineNumber, 5);
            vulnerabilities.push({
              id: generateId(),
              type: "code_injection",
              severity: "high",
              category: "Security",
              title: "Use of Function constructor detected",
              description:
                "Function constructor can execute arbitrary code and is a security risk.",
              affectedFiles: [
                {
                  path: file,
                  line: lineNumber,
                  codeSnippet: codeSnippet || undefined,
                },
              ],
              cweId: "CWE-94",
              references: ["https://cwe.mitre.org/data/definitions/94.html"],
              suggestedFix:
                "Avoid Function constructor. Use regular function declarations or arrow functions.",
            });
          }
        });
      } catch (error) {
        console.error(
          `[SecurityAnalyzer] Error detecting vulnerabilities in file ${file}:`,
          error instanceof Error ? error.message : String(error)
        );
        // Continue processing other files
      }
    }

    return vulnerabilities;
  }

  private calculateSecurityScore(analysis: SecurityAnalysis): number {
    // Score deduction constants
    const CRITICAL_SECRET_DEDUCTION = 20;
    const CRITICAL_HOTSPOT_DEDUCTION = 15;
    const HIGH_SECRET_DEDUCTION = 10;
    const HIGH_HOTSPOT_DEDUCTION = 8;
    const HIGH_VULNERABILITY_DEDUCTION = 8;
    const _MEDIUM_SECRET_DEDUCTION = 5;
    const MEDIUM_HOTSPOT_DEDUCTION = 3;
    const MEDIUM_VULNERABILITY_DEDUCTION = 3;

    let score = 100;

    // Deduct points for critical findings
    score -=
      analysis.secrets.filter((s) => s.severity === "critical").length *
      CRITICAL_SECRET_DEDUCTION;
    score -=
      analysis.securityHotspots.filter((h) => h.severity === "critical")
        .length * CRITICAL_HOTSPOT_DEDUCTION;

    // Deduct points for high findings
    score -=
      analysis.secrets.filter((s) => s.severity === "high").length *
      HIGH_SECRET_DEDUCTION;
    score -=
      analysis.securityHotspots.filter((h) => h.severity === "high").length *
      HIGH_HOTSPOT_DEDUCTION;
    score -=
      analysis.vulnerabilities.filter((v) => v.severity === "high").length *
      HIGH_VULNERABILITY_DEDUCTION;

    // Deduct points for medium findings
    // Note: secrets can only be "critical" or "high", so we skip medium for secrets
    score -=
      analysis.securityHotspots.filter((h) => h.severity === "medium").length *
      MEDIUM_HOTSPOT_DEDUCTION;
    score -=
      analysis.vulnerabilities.filter((v) => v.severity === "medium").length *
      MEDIUM_VULNERABILITY_DEDUCTION;

    return Math.max(0, score);
  }
}
